/* 
 * ml_dictionary_gen.c
 *
 * Copyright 2014 Pallavi Project <pallavi.malayalam@gmail.com>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>

char *phones_of_3[] = {
	"txh", "dhx", "rrq", "nxq", "lxq"
};

char *phones_of_2[] = {
	"hq", "aa", "ii", "uu", "rq", "lx", "ei", "ai", "oo", "au", "kh",
	"gh", "ng", "ch", "jh", "nj", "tx", "dh", "nx", "th", "dh", "ph", "bh",
	"rx", "lx", "zh", "sh", "sx", "aa", "ii", "uu", "rq", "ei", "ai", "oo",
	"au", "au", "nq", "rq", "lq"
};

char *phones_of_1[] = {
	"q", "a", "i", "u", "e", "o", "k", "g", "c", "j", "t", "d", "n", "p",
	"b", "m", "y", "r", "l", "w", "s", "h", "i",	"u", "e", "o"
};

char *check_for_phone(char *phone)
{
	int nelm = 0, len = 0, i = 0;
	char **phoneset = NULL;

	if (phone == NULL)
		return NULL;

	len = strlen(phone);

	switch (len) {
		case 1: nelm = sizeof(phones_of_1)/sizeof(char*);
			   phoneset = (char**)phones_of_1;
			   break;

		case 2: nelm = sizeof(phones_of_2)/sizeof(char*);
			   phoneset = (char**)phones_of_2;
			   break;

		case 3: nelm = sizeof(phones_of_3)/sizeof(char*);
			   phoneset = (char**)phones_of_3;
			   break;

		default: return NULL;
	}

	while (i < nelm) {
		if (!strncmp(phoneset[i], phone, len)) {
			return phoneset[i];
		}
		i++;
	}

	return NULL;
}

/* The list file contains one word per line. Read the word and try characters
 * in 3, 2, 1 numbers and see if the phone exist in the list */
#define MAX_WORD_LENGTH 256

void process_list_file(FILE *ifp, FILE *ofp)
{
	char buffer[MAX_WORD_LENGTH];
	char phone[4];
	char *pos = NULL;
	int len = 0;

	while(fgets(buffer, sizeof(buffer), ifp) != 0) {
		/* Skip empty lines - Would have been nice if we can have the kernel
		 * style unlikely(). Chance of the following is really small. Some 
		 * branch prediction would be useful. (Performance :) ) */
		if (buffer[0] == '\n')
			continue;
		/* Remove the trailing new line */
		buffer[strlen(buffer)-1] = '\0';

		pos = buffer;

		fprintf(ofp, "%s\t", pos);

		while (*pos) {
			strncpy(phone, pos, 3);
			phone[3] = '\0';
			len = 3; /* Just assume */
			while (len) {
				len = strlen(phone);
				if (check_for_phone(phone)) {
					fprintf(ofp, "%s ", phone);
					break;
				} else {
					if (len == 1) {
						printf("Error translating: '%s'\n", buffer);
						printf("Missing phone is: '%s'\n", phone);
						break;
					}
					phone[len-1] = '\0';
				}
			}

			pos += len;
		}

		fprintf(ofp, "\n");
	}
}

void print_help(char *progname)
{
	printf("\nUsage: %s --wordlist(-w) <word list> --dict(-d) <dict file>"
		"\n\n", progname);
	printf("--help(-h) option displays this message\n");
	printf("\n%s Generates a dictionary for Malayalam language\n", progname);
	printf("model for using with speech recognition from input word list\n\n"
		"<word list> file should be generated by pallavi_mltxt2wordlist\n"
		"This file would contain a list of unique words generated from\n"
		"various input files that contain transliterated Malayalam words\n\n"
		"<dict file> is the output dictionary file name to be used to store\n"
		"generated dictionary"
		"\n\n");
}

static int flag_help = 0, flag_wlist = 0, flag_dict = 0;
static int optindx = 0, opt = 0;

static struct option opts[] = {
	{"help", no_argument, &flag_help, 1},
	{"wordlist", required_argument, 0, 'w'},
	{"dict", required_argument, 0, 'd'},
	{0, 0, 0, 0}
};

int main(int argc, char *argv[])
{
	char *wlist = NULL, *dictfile = NULL;
	FILE *ifp = NULL, *ofp = NULL;

	while (1) {
		opt = getopt_long(argc, argv, "hw:d:", opts, &optindx);
		if (opt == -1)
			break;

		switch(opt) {
			case 'w':
				flag_wlist = 1;
				wlist = strdup(optarg);
			break;

			case 'd':
				flag_dict = 1;
				dictfile = strdup(optarg);
			break;

			case 'h':
				flag_help = 1;
			break;

			default:
			break;
		}
	}

	if ((flag_wlist == 0) || (flag_dict == 0) || flag_help) {
		print_help(argv[0]);
		goto clean;
	}
	
	printf("Using %s as wordlist and %s as dictionary file\n",
		wlist, dictfile);

	ifp = fopen(wlist, "r");
	if (ifp == NULL)
		goto clean;
	
	ofp = fopen(dictfile, "w+");
	if (ofp == NULL)
		goto clean;
	
	process_list_file(ifp, ofp);
	fflush(ofp);

clean:
	if (wlist)
		free(wlist);
	if (dictfile)
		free(dictfile);
	if (ifp)
		fclose(ifp);
	if (ofp)
		fclose(ofp);

	return 0;
}

